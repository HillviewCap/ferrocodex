# Story 5.1A: Basic Hierarchy Foundation

## Story Information

- **Epic:** 5 - Asset-Centric Hierarchical Management
- **Story:** 5.1A
- **Title:** Basic Hierarchy Foundation
- **Status:** done
- **Points:** 5
- **Assignee:** Development Agent

## Story Statement

As an Engineer, I want the system to support hierarchical asset organization at the data layer, so that I can organize my industrial environment logically with proper parent-child relationships.

## Acceptance Criteria

1. Assets can have parent-child relationships with unlimited depth
2. Data model supports both folder and device asset types
3. Repository operations handle hierarchy queries efficiently
4. IPC commands provide hierarchy creation and navigation
5. Circular reference prevention is implemented

## Dev Notes

### Previous Story Context
From previous Epic 4 completion, the following foundation is available:
- Asset management system with creation, import, and basic organization
- User authentication with role-based access control (Administrator, Engineer)
- Dashboard interface with asset display capabilities
- Configuration management with encrypted storage
- SQLite database with asset and configuration tables
- Tauri IPC command structure for asset operations

### Technical Framework Overview
[Source: docs/ARCHITECTURE.md#tech-stack]
- **Backend Language:** Rust ~1.78.0 for core application logic and security
- **Frontend Language:** TypeScript ~5.4.5 for UI development
- **Frontend Framework:** React ~18.3.1 for UI library
- **UI Component Library:** Ant Design (AntD) ~5.17.4 for pre-built UI components
- **State Management:** Zustand ~4.5.2 for UI state management
- **Database:** SQLite ~3.45.3 for local, embedded data storage
- **DB Access (Rust):** rusqlite crate ~0.31.0 for Rust-SQLite interface
- **App Framework:** Tauri ~2.0.0-beta for cross-platform desktop app shell

### Architecture Pattern
[Source: docs/ARCHITECTURE.md#architectural-patterns]
- **Primary Pattern:** Modular Monolith for desktop application
- **Component Pattern:** Component-Based UI using React
- **Backend Pattern:** Repository Pattern in Rust core for database abstraction
- **Database Pattern:** Local encrypted SQLite database for offline-first operation

### Data Models
Based on Story 5.1A requirements, the following foundational data model changes are needed:
- **Asset Model Enhancement:** Add asset_type field ('folder' | 'device')
  - Fields: id, name, description, asset_type, parent_id, created_by, created_at, updated_at, sort_order
- **Asset Hierarchy Model:** Support parent-child relationships
  - Self-referencing foreign key: parent_id references assets.id
  - Hierarchical queries for ancestor/descendant retrieval
- **Circular Reference Prevention:** Validation logic to prevent invalid hierarchy moves
  - Path validation algorithms to detect circular references
  - Depth limit validation (configurable, default 50 levels)

### API Specifications
Tauri IPC commands needed for Story 5.1A foundational layer:
- **create_asset_with_hierarchy(name, description, asset_type, parent_id?):** Create asset with hierarchy support
- **get_asset_hierarchy():** Retrieve complete asset tree structure
- **get_asset_children(parent_id?):** Get direct children of a parent (or root level)
- **move_asset(asset_id, new_parent_id?):** Move asset to different parent
- **validate_hierarchy_move(asset_id, new_parent_id):** Validate move operation (prevent circular references)
- **get_asset_ancestors(asset_id):** Get path from root to asset for breadcrumbs

### Component Specifications
[Source: docs/ARCHITECTURE.md#component-based-ui and established patterns]
This story focuses on foundational data layer - minimal UI components:
- **AssetHierarchyTypes:** TypeScript interfaces for hierarchy data structures
- **HierarchyValidation:** Utility functions for client-side validation
- **AssetTreeData:** Data transformation utilities for tree structures

### File Locations
Based on established project structure:
- **Rust Backend:** Extend `apps/desktop/src-tauri/src/assets/`
  - `apps/desktop/src-tauri/src/assets/hierarchy.rs` - New hierarchy operations module
  - `apps/desktop/src-tauri/src/assets/repository.rs` - Enhanced with hierarchy methods
- **Database Module:** Extend `apps/desktop/src-tauri/src/database/` with hierarchy support
  - `apps/desktop/src-tauri/src/database/migrations/` - Add hierarchy migration
- **Types:** `apps/desktop/src/types/hierarchy.ts` - TypeScript type definitions

### Testing Requirements
[Source: docs/ARCHITECTURE.md#testing-strategy]
- **Unit Tests:** Rust hierarchy logic and circular reference prevention
- **Database Tests:** Hierarchical queries and foreign key constraints
- **Integration Tests:** IPC command functionality and data integrity
- **Performance Tests:** Query efficiency with deep hierarchies (1000+ assets)

### Technical Constraints
[Source: docs/ARCHITECTURE.md and PRD requirements]
- Must maintain existing asset encryption and security (AES-256)
- Hierarchical queries must perform efficiently (< 1 second for 1000+ assets)
- Must prevent circular reference creation during move operations
- Tree structure must handle unlimited nesting depth without performance degradation
- Database operations must be atomic to maintain data integrity

### Security Requirements
[Source: PRD NFR2 and established security patterns]
- Hierarchical operations must respect user permissions and roles
- Asset move operations must validate ownership and access rights
- Prevent unauthorized access to folder contents through path traversal
- Maintain audit trail for all hierarchy changes and asset moves
- Validate parent-child relationships to prevent data integrity issues

## Tasks / Subtasks

### Task 1: Enhance Asset Data Model for Hierarchy (AC: 1, 2, 3)
[Source: PRD FR1 and hierarchical data requirements]
- [ ] 1.1. Update Asset model in Rust backend
  - Add asset_type enum field ('folder' | 'device')
  - Add parent_id optional foreign key field (references assets.id)
  - Add sort_order field for custom ordering within parents
  - Update existing Asset struct with hierarchy fields
- [ ] 1.2. Create database migration for hierarchy support
  - Migration script to add new fields to existing assets table
  - Add asset_type column with default value 'device' for existing records
  - Add parent_id column with proper foreign key constraint
  - Add sort_order column with default sequential values
  - Create database indexes for parent_id and sort_order fields
  - Add ON DELETE CASCADE for parent_id foreign key constraint
- [ ] 1.3. Create hierarchy validation functions
  - Implement circular reference detection algorithm using recursive queries
  - Add depth limit validation (configurable limit, default 50 levels)
  - Create asset move validation with ancestry path checking
  - Add parent-child relationship integrity validation functions
  - Implement path traversal prevention in hierarchy queries
- [ ] 1.4. Update TypeScript interfaces for frontend
  - Enhance Asset interface with hierarchy fields (asset_type, parent_id, sort_order)
  - Create AssetHierarchy interface for tree structures with children arrays
  - Add AssetType enum ('folder' | 'device') for type safety
  - Create validation schemas for hierarchy operations using zod
  - Add type guards for folder vs device assets (isFolder, isDevice functions)

### Task 2: Implement Hierarchy Repository Operations (AC: 1, 2, 3, 5)
[Source: Repository pattern and hierarchical data management]
- [ ] 2.1. Create hierarchical CRUD operations in AssetRepository
  - Implement create_asset_with_hierarchy(name, description, asset_type, parent_id, user_id) -> Result<Asset, String>
  - Add get_asset_hierarchy() -> Result<Vec<AssetHierarchyNode>, String> for complete tree
  - Add get_asset_children(parent_id: Option<u32>) -> Result<Vec<Asset>, String> for specific level
  - Add get_asset_ancestors(asset_id: u32) -> Result<Vec<Asset>, String> for breadcrumb paths
  - Implement get_asset_descendants(asset_id: u32) -> Result<Vec<Asset>, String> for subtree operations
- [ ] 2.2. Implement asset move operations with validation
  - Create move_asset(asset_id: u32, new_parent_id: Option<u32>) -> Result<(), String>
  - Add validate_hierarchy_move(asset_id: u32, new_parent_id: Option<u32>) -> Result<bool, String>
  - Implement circular reference detection using recursive CTE queries
  - Add depth validation to prevent excessively deep hierarchies
  - Create transaction-based move operations to ensure data integrity
- [ ] 2.3. Optimize hierarchy queries for performance
  - Implement recursive Common Table Expression (CTE) queries for efficient tree traversal
  - Add database indexes on parent_id and asset_type for fast hierarchy lookups
  - Create materialized path calculation for O(1) ancestor/descendant checks
  - Optimize sort_order updates to minimize database writes during moves
  - Add query result caching for frequently accessed hierarchy paths
- [ ] 2.4. Add comprehensive hierarchy repository tests
  - Test asset creation with various parent-child relationship scenarios
  - Test move operations and circular reference prevention algorithms
  - Test hierarchy queries with deep nesting (up to 50 levels)
  - Test concurrent operations and database transaction integrity
  - Performance benchmarks with 1000+ assets across 20+ hierarchy levels
  - Test edge cases: orphaned assets, invalid parent references, depth limits

### Task 3: Create Hierarchy Management IPC Commands (AC: 1, 2, 3, 5)
[Source: Tauri IPC architecture pattern and hierarchy requirements]
- [ ] 3.1. Implement foundational hierarchy IPC commands
  - create_asset_with_hierarchy(name: String, description: String, asset_type: String, parent_id: Option<u32>) -> Result<Asset, String>
  - get_asset_hierarchy() -> Result<AssetHierarchy, String> - returns complete tree structure
  - get_asset_children(parent_id: Option<u32>) -> Result<Vec<Asset>, String> - returns direct children
  - validate_asset_creation(name: String, parent_id: Option<u32>) -> Result<bool, String>
  - Ensure all commands verify user authentication and role-based permissions
- [ ] 3.2. Implement hierarchy navigation IPC commands
  - get_asset_path(asset_id: u32) -> Result<Vec<Asset>, String> for breadcrumb navigation
  - get_asset_ancestors(asset_id: u32) -> Result<Vec<Asset>, String> - path from root to asset
  - get_asset_descendants(asset_id: u32) -> Result<Vec<Asset>, String> - all children recursively
  - get_asset_siblings(asset_id: u32) -> Result<Vec<Asset>, String> - assets with same parent
  - search_assets_in_hierarchy(query: String, parent_id: Option<u32>) -> Result<Vec<Asset>, String>
- [ ] 3.3. Implement asset organization IPC commands
  - move_asset(asset_id: u32, new_parent_id: Option<u32>) -> Result<(), String>
  - validate_hierarchy_move(asset_id: u32, new_parent_id: Option<u32>) -> Result<bool, String>
  - reorder_assets(parent_id: Option<u32>, asset_order: Vec<u32>) -> Result<(), String>
  - get_move_validation_errors(asset_id: u32, new_parent_id: Option<u32>) -> Result<Vec<String>, String>
  - bulk_move_assets(asset_ids: Vec<u32>, new_parent_id: Option<u32>) -> Result<Vec<MoveResult>, String>
- [ ] 3.4. Add comprehensive IPC command testing
  - Test all creation commands with various parent scenarios and edge cases
  - Test navigation commands with deep hierarchies and performance validation
  - Test organization commands including circular reference prevention
  - Test error handling, validation, and proper error message formatting
  - Test permission validation for different user roles (Administrator vs Engineer)
  - Integration tests for command chaining (create → move → validate workflows)

## Testing

### Test Strategy
- **Unit Tests:** Rust hierarchy operations and circular reference prevention using built-in test framework
- **Database Tests:** SQL migrations, foreign key constraints, and hierarchical query performance
- **Integration Tests:** IPC command functionality and cross-layer data integrity using Rust integration tests
- **Performance Tests:** Query efficiency and memory usage with large hierarchies (1000+ assets)

### Test Cases
1. **TC-5.1A.1:** Verify asset creation with hierarchy fields (asset_type, parent_id, sort_order)
2. **TC-5.1A.2:** Test database migration adds hierarchy fields without data loss
3. **TC-5.1A.3:** Validate circular reference prevention in asset moves
4. **TC-5.1A.4:** Test unlimited depth folder nesting (up to configured limit of 50)
5. **TC-5.1A.5:** Verify repository operations maintain data integrity during concurrent access
6. **TC-5.1A.6:** Test IPC commands return proper hierarchy data structures
7. **TC-5.1A.7:** Validate query performance with large asset trees (< 1 second for 1000+ assets)
8. **TC-5.1A.8:** Test hierarchy validation functions prevent invalid operations
9. **TC-5.1A.9:** Verify asset move operations update sort_order correctly
10. **TC-5.1A.10:** Test edge cases: orphaned assets, invalid parent references, depth limits
11. **TC-5.1A.11:** Validate foreign key constraints prevent data integrity issues
12. **TC-5.1A.12:** Test audit trail captures all hierarchy modification operations

### Test Data Requirements
- Sample hierarchical asset structures with various depths (1-50 levels)
- Large dataset (1000+ assets) for performance and scalability testing
- Edge cases: circular reference attempts, maximum depth scenarios, orphaned assets
- User accounts with different permissions for role-based access testing
- Assets with various metadata to test hierarchy operations with complex data

### Performance Criteria
- Asset creation with hierarchy < 500ms response time
- Hierarchy tree retrieval < 1 second for structures with 1000+ assets
- Asset move validation < 200ms for circular reference detection
- Ancestor/descendant queries < 300ms for depth up to 20 levels
- Database migration completes < 30 seconds for 10,000 existing assets
- Memory usage < 50MB for hierarchy operations in Rust backend
- IPC command response times < 100ms for simple hierarchy operations
- Concurrent hierarchy operations maintain data consistency without deadlocks

## Change Log

### v1.0 - Initial Creation
- Created foundational story for hierarchical asset data model
- Defined core hierarchy support at repository and IPC command levels
- Added comprehensive circular reference prevention requirements
- Included performance optimization specifications for large hierarchies
- Focused on data layer foundation without complex UI components

## Notes

This story establishes the foundational data layer for hierarchical asset management, focusing on robust data modeling, efficient repository operations, and secure IPC commands. It serves as the prerequisite for more complex hierarchy features in subsequent stories (5.1B, 5.1C) by ensuring the core data structures and operations are solid, performant, and secure. The emphasis is on data integrity, circular reference prevention, and query optimization to support the complex UI features that will be built on top of this foundation.